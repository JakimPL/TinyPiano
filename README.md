# Piano Harmonics Neural Network - C Implementation

This project implements a neural network model for predicting piano harmonics in pure C, without any external libraries. The model takes normalized inputs (pitch, velocity, harmonic, time) and outputs log amplitude.

## Architecture

- **Input**: 4 features (pitch, velocity, harmonic, time) - all normalized to [0, 1]
- **Hidden layers**: 4 → 8 → 8 → 4 → 1
- **Activation**: SiLU (Swish) activation function
- **Output**: Log amplitude (use `expf()` to get actual amplitude)

## Files

### C Implementations

- **`src/model.h`** - Header file with function declarations
- **`src/model.c`** - Implementation of neural network functions
- **`src/main.c`** - Main program with test procedure
- **`src/weights.h`** - Header file with weight array declarations and size constants
- **`src/weights.c`** - Generated file containing actual weight data (generated by Python script)

### Python Tools

- **`python/extract_weights.py`** - Extracts weights from PyTorch model and generates weights.c file
- **`python/model.py`** - PyTorch model definition
- **`python/constants.py`** - Configuration constants and file paths
- **Other Python files** - Training, testing, and data processing utilities

### Build System

- **`Makefile`** - Build system for the model

## Quick Start

```bash
# Generate weights from trained model (or use random weights if model not found)
python python/extract_weights.py

# Build the model
make model

# Run the test
./model

# Clean build artifacts
make clean
```

## Usage Example

```c
#include "src/model.h"

int main() {
    float pitch = 0.5f;      // Middle of piano range
    float velocity = 0.8f;   // Strong key press
    float harmonic = 0.1f;   // First few harmonics
    float time = 0.3f;       // 30% into note duration

    float log_amp = predict_amplitude(pitch, velocity, harmonic, time);
    float amplitude = expf(log_amp);

    printf("Log amplitude: %.6f, Amplitude: %.6f\n", log_amp, amplitude);
    return 0;
}
```

To compile your own program:
```bash
gcc -O2 -o your_program your_program.c src/model.c src/weights.c -lm
```

## Model Performance

The C implementation produces test output with random weights:

```
Input: (0.50, 0.50, 0.00, 0.00)
Log amplitude: 0.392999
Amplitude: 1.481417
```

(Results will vary with random weights until a trained model is loaded)

## Compiling

The code requires only standard C libraries and math library:

```bash
gcc -O2 -o model src/main.c src/model.c src/weights.c -lm
```

## Code Size

The modular implementation consists of:
- **Source**: Separated into model functions and weight data
- **Binary**: ~8KB (optimized with `-O2`)
- **Dependencies**: Only standard C library + libm

## Technical Details

- **Precision**: Single precision floating point (32-bit)
- **Memory**: All weights embedded as static arrays
- **Standards**: C99 compatible
- **Tested**: GCC on Linux

## Extending

To retrain the model or modify architecture:
1. Update the PyTorch model in `python/model.py`
2. Train and save weights to `models/tiny.pth`
3. Run `python python/extract_weights.py` to regenerate `src/weights.c`
4. Rebuild with `make model`
