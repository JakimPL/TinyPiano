# Piano Harmo### C Implementations

- **`src/model.h`** - Header file with neural network function declarations
- **`src/model.c`** - Implementation of neural network functions (pure functions, no main)
- **`src/main.c`** - Main program with neural network test procedure
- **`src/synth.h`** - Header file with synthesizer function declarations
- **`src/synth.c`** - Real-time audio synthesizer implementation using the neural network
- **`src/test_synth.c`** - Test program for the synthesizer
- **`src/weights.h`** - Header file with weight array declarations and size constants
- **`src/weights.c`** - Generated file containing actual weight data (generated by Python script)ural Network - C Implementation

This project implements a neural network model for predicting piano harmonics in pure C, without any external libraries. The model takes normalized inputs (pitch, velocity, harmonic, time) and outputs log amplitude.

## Architecture

- **Input**: 4 features (pitch, velocity, harmonic, time) - all normalized to [0, 1]
- **Hidden layers**: 4 → 8 → 8 → 4 → 1
- **Activation**: SiLU (Swish) activation function
- **Output**: Log amplitude (use `expf()` to get actual amplitude)

## Files

### C Implementations

- **`src/model.h`** - Header file with function declarations
- **`src/model.c`** - Implementation of neural network functions
- **`src/main.c`** - Main program with test procedure
- **`src/weights.h`** - Header file with weight array declarations and size constants
- **`src/weights.c`** - Generated file containing actual weight data (generated by Python script)

### Python Tools

- **`python/extract_weights.py`** - Extracts weights from PyTorch model and generates weights.c file
- **`python/model.py`** - PyTorch model definition
- **`python/constants.py`** - Configuration constants and file paths
- **Other Python files** - Training, testing, and data processing utilities

### Build System

- **`Makefile`** - Build system for the model

## Quick Start

```bash
# Generate weights from trained model (or use random weights if model not found)
python python/extract_weights.py

# Build all programs
make all

# Test the neural network model
./model

# Test the synthesizer
./test_synth

# Clean build artifacts
make clean
```

## Usage Example

### Neural Network Model
```c
#include "src/model.h"

int main() {
    float pitch = 0.5f;      // Middle of piano range
    float velocity = 0.8f;   // Strong key press
    float harmonic = 0.1f;   // First few harmonics
    float time = 0.3f;       // 30% into note duration

    float log_amp = predict_amplitude(pitch, velocity, harmonic, time);
    float amplitude = expf(log_amp);

    printf("Log amplitude: %.6f, Amplitude: %.6f\n", log_amp, amplitude);
    return 0;
}
```

### Audio Synthesizer
```c
#include "src/synth.h"
#include <stdlib.h>

int main() {
    int pitch = 69;        // A4 (440 Hz)
    int velocity = 100;    // Strong velocity
    float duration = 1.0f; // 1 second

    size_t buffer_size = duration * SAMPLE_RATE;
    float* buffer = malloc(buffer_size * sizeof(float));

    size_t samples = synthesize_note(buffer, buffer_size,
                                   pitch, velocity, duration, SAMPLE_RATE);

    // Use the generated waveform (buffer contains audio samples)
    // ...

    free(buffer);
    return 0;
}
```

To compile your own program:
```bash
# Neural network only
gcc -O2 -o your_program your_program.c src/model.c src/weights.c -lm

# With synthesizer
gcc -O2 -o your_program your_program.c src/synth.c src/model.c src/weights.c -lm
```

## Model Performance

### Neural Network Test
The C implementation produces test output with random weights:

```
Input: (0.50, 0.50, 0.00, 0.00)
Log amplitude: 0.392999
Amplitude: 1.481417
```

### Synthesizer Test
The synthesizer generates realistic audio waveforms:

```
Synthesizing note:
  Pitch: 69 (440.00 Hz)
  Velocity: 100
  Duration: 1.00 seconds
  Sample rate: 48000 Hz
  Buffer size: 48000 samples
Generated 48000 samples

RMS level: 0.169687
Peak level: 1.000000
```

(Results will vary with random weights until a trained model is loaded)

## Compiling

The code requires only standard C libraries and math library:

```bash
gcc -O2 -o model src/main.c src/model.c src/weights.c -lm
```

## Code Size

The modular implementation consists of:
- **Source**: Separated into model functions and weight data
- **Binary**: ~8KB (optimized with `-O2`)
- **Dependencies**: Only standard C library + libm

## Technical Details

- **Precision**: Single precision floating point (32-bit)
- **Memory**: All weights embedded as static arrays
- **Standards**: C99 compatible
- **Tested**: GCC on Linux

## Extending

To retrain the model or modify architecture:
1. Update the PyTorch model in `python/model.py`
2. Train and save weights to `models/tiny.pth`
3. Run `python python/extract_weights.py` to regenerate `src/weights.c`
4. Rebuild with `make model`
